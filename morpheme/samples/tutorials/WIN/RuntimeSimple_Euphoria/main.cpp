// Copyright (c) 2013 NaturalMotion.  All Rights Reserved.
// Not to be copied, adapted, modified, used, distributed, sold,
// licensed or commercially exploited in any manner without the
// written consent of NaturalMotion.
//
// All non public elements of this software are the confidential
// information of NaturalMotion and may not be disclosed to any
// person nor used for any purpose not expressly approved by
// NaturalMotion in writing.

//----------------------------------------------------------------------------------------------------------------------
#include "NMPlatform/NMPrioritiesLogger.h"
#include "NMPlatform/NMSocket.h"
#include "morpheme/mrDebugManager.h"
#include "morpheme/mrManager.h"
#include "comms/commsServer.h"
#include "comms/physicsCommsServerModule.h"
#include "comms/physicsRuntimeTargetSimple.h"
#include "comms/runtimeTargetNull.h"
#include "comms/simpleConnectionManager.h"
#include "comms/liveLinkDataManager.h"
#include "comms/liveLinkNetworkManager.h"
#include "comms/euphoriaCommsServerModule.h"

#include "GameManagement/Euphoria/GameAnimSystemModuleEuphoria.h"
#include "GameManagement/Euphoria/GameEuphoriaManager.h"
#include "GameManagement/Euphoria/GameCharacterEuphoria.h"
#include "GameManagement/Euphoria/GameCharacterManagerEuphoria.h"

// HARDWIRED FOR NOW, UNTIL WE SUPPORT MULTIPLE LIBS / NS
#include "AutoGenerated/NetworkForceInclude.h"
#include "AutoGenerated/NetworkDescriptor.h"

#include <conio.h>      // _getch(), _kbhit()

#define ASSETLOCATION "./ProjectData/" PLATFORMDIR
#define NETWORK_DEF_BUNDLE_NAME ASSETLOCATION "/Network_EuphoriaAndAnimation.nmb"

namespace 
{

//----------------------------------------------------------------------------------------------------------------------
const char FORWARDS_NAME[] = "Forwards";
const char EUPHORIA_NAME[] = "Euphoria";
const char GETUP_NAME[] = "GetUp";
const char SPEED_NAME[] = "ControlParameters|Speed";
const char BANKING_NAME[] = "ControlParameters|Banking";

MR::MessageID forwardsMessageID = MR::INVALID_MESSAGE_ID;
MR::MessageID euphoriaMessageID = MR::INVALID_MESSAGE_ID;
MR::MessageID getupMessageID = MR::INVALID_MESSAGE_ID;
MR::NodeID speedCPNodeID = MR::INVALID_NODE_ID;
MR::NodeID bankingCPNodeID = MR::INVALID_NODE_ID;

//----------------------------------------------------------------------------------------------------------------------
int32_t runNetwork(
  Game::EuphoriaManager&          physXManager,
  Game::CharacterManagerEuphoria& characterManager)
{
  //----------------------------
  // Create the Euphoria character from its definition.
  //
  Game::CharacterDefEuphoria* characterDefEuphoria = (Game::CharacterDefEuphoria*) characterManager.getCharacterDef(0);
  NMP_STDOUT("\nCreating GameCharacter from GameCharacterDef:");
  Game::CharacterEuphoria* gameCharacter = characterManager.createCharacter(characterDefEuphoria);
  if (!gameCharacter)
  {
    NMP_STDOUT("error: Failed to create character!");
    return false;
  }
  gameCharacter->setName("Character");

  //------------------------------------------------------------------------------------------------------------------
  // Set initial network states. For example the PhysicstToAnimation starts out in an idle state, we tell it to
  // transition to a (more interesting) locomotion state.
  gameCharacter->broadcastRequestMessage(forwardsMessageID, true);


  //------------------------------------------------------------------------------------------------------------------
  // Update for a finite period of time with a fixed step size
  static const int FPS = 30;
  static const float DELTA_TIME = 1.0f / (float)FPS;
  static const float maxTime = 60.0f;

  uint32_t frameCounter = 0;
  uint32_t state = 1;
  uint32_t maxFrames = (uint32_t) (maxTime / DELTA_TIME);
  for (frameCounter = 0 ; frameCounter != maxFrames ; ++frameCounter)
  {
    if((frameCounter % 100) == 0)
    {
      //----------------------------
      // Simple state machine to trigger our character's state transitions.
      switch (state)
      {
        case 0:
          //----------------------------
          // Move into Forward state
          gameCharacter->broadcastRequestMessage(forwardsMessageID, true);
          state++;
          break;
        case 1:
          //----------------------------
          // Move into Euphoria state
          gameCharacter->broadcastRequestMessage(euphoriaMessageID, true);
          state++;
          break;
        case 2:
          //----------------------------
          // Move into Getup state
          gameCharacter->broadcastRequestMessage(getupMessageID, true);
          state = 0;
          break;
        default:
          break;
      }
    }

    // Lock to one thread for timing purposes.
    NMP::LockThreadAffinityForTiming();

    {
      NMP::Timer updateTimer;

      // Schedule PreCharacterControllerTasks then wait for all the update tasks to complete.
      characterManager.updatePreCharacterController(DELTA_TIME);

      // Update each characters Euphoria character controller.
      characterManager.updateCharacterController(DELTA_TIME);

      // Schedule PostCharacterControllerTasks then wait for all the update tasks to complete.
      characterManager.updatePostCharacterController(DELTA_TIME);

      // Apply cached PhysX rig updates here.
      //  Done as a separate step because setting physics engine values may not be thread safe in some situations.
      characterManager.updatePrePhysics(DELTA_TIME);

      // Run the physics simulation step.
      physXManager.simulate(DELTA_TIME);

      // Update the cache off all physics rigs with the PhysX data computed during the simulation step.
      characterManager.updatePostPhysics(DELTA_TIME);

      // Schedule FinaliseTasks then wait for all the update tasks to complete.
      //  Note: Each Character instance has its own temporary memory allocator that is reset after its final update.
      characterManager.updateFinalise(DELTA_TIME);

      float elapsedTime = updateTimer.stop();
#ifdef NMP_MEMORY_LOGGING
      printf("Elapsed Time: %.2f - %d\n", elapsedTime, NMP::Memory::totalAllocatedBytes());
#else
      printf("Elapsed Time: %.2f\n", elapsedTime);
#endif
    }
  }

  return true;
}

} // anonymous namespace

//----------------------------------------------------------------------------------------------------------------------
// RuntimeSimple_Euphoria: This tutorial demonstrates how to create a simple runtime target that
// loads a Euphoria character and network, and steps the PhysX system and Morpheme, including a few
// simple transitions between Morpheme states.
//
// In order to visualise the output, we recommend running the PhysX Visual Debugger, though note
// that this will show only the physical character.
int32_t main(int32_t NMP_UNUSED(argc), char** NMP_UNUSED(argv))
{
  //----------------------------
  // This program defaults to loading the "Network" from the ProjectData folder. The animation files will 
  // be loaded from the ASSETLOCATION; see Game::CharacterDef::loadAnimationsFromDisk() for more details.
  NMP_STDOUT("Defaulting <network1 filename> to : '%s'", ASSETLOCATION);

  //----------------------------
  // Initialize PhysX
  Game::EuphoriaManager physXManager;
  NMP_STDOUT("Initialising PhysX");
  physXManager.init();
  physx::PxScene* physXScene = physXManager.createScene();
  if (!physXScene)
  {
    NMP_STDOUT("error: unable to create physics");
    return false;
  }

  //---------------------------
  // Use the PhysX debugger for visualisation, if it's running, since this tutorial doesn't contain
  // any rendering or support connections to Morpheme Connect.
  physXManager.connectToPhysXVisualDebugger();

  //---------------------------
  // Create a simple physical environment, in this case a plane the character can stand on.
  physx::PxRigidActor* physXGroundObject = physXManager.createPhysicsObjectGroundPlane();
  if (!physXGroundObject)
  {
    NMP_STDOUT("error: Failed to create ground plane!");
    return false;
  }

  //----------------------------
  // Game::CharacterManagerEuphoria is a static class which will act as a manager for all the morpheme network definitions 
  // and network instances. In this case we are passing in a PhysX module in order to initialise the physics 
  // world.
  Game::CharacterManagerEuphoria characterManager;
  Game::AnimSystemModuleEuphoria::init();
  characterManager.init();
  characterManager.attachToPhysXScene(
                      physXManager.getPhysXScene(),
                      physXManager.getPhysXCharacterControllerManager());
    
  //----------------------------
  // We also need an instance of a GameCharacterDef that will be initialised with the binary asset data. Using the
  // GameAnimModule manager class we will initialise our GameCharacterDef. This will load the file found at 
  // NETWORKPATH and use that information to apply to the character definition instance.
  NMP_STDOUT("\nCreating GameCharacterDefs:");
  Game::CharacterDefEuphoria* characterDefEuphoria = characterManager.createCharacterDef(NETWORK_DEF_BUNDLE_NAME);
  if (!characterDefEuphoria)
  {
    NMP_STDOUT("error: Failed to load bundle <%s>!", NETWORK_DEF_BUNDLE_NAME);
    return false;
  }
    
  //----------------------------
  // Load the animations associated with the anim set of the CharacterDef loaded from the exported network asset file
  // on disk.
  NMP_STDOUT("\nLoading Animation files for Character Definition 1:");  
  if (!characterDefEuphoria->loadAnimationsFromDisk(ASSETLOCATION))
  {
    NMP_STDOUT("\nload Animations for Game Character Definition 1 returned error");
    return false;
  }

  // We cache the request and control parameter node IDs for faster runtime access.
  forwardsMessageID = characterDefEuphoria->getNetworkDef()->getMessageIDFromMessageName(FORWARDS_NAME);
  NMP_ASSERT_MSG(forwardsMessageID != MR::INVALID_MESSAGE_ID, "Request does not exist (name=%s)!", FORWARDS_NAME);

  euphoriaMessageID = characterDefEuphoria->getNetworkDef()->getMessageIDFromMessageName(EUPHORIA_NAME);
  NMP_ASSERT_MSG(forwardsMessageID != MR::INVALID_MESSAGE_ID, "Request does not exist (name=%s)!", EUPHORIA_NAME);

  speedCPNodeID = characterDefEuphoria->getNetworkDef()->getNodeIDFromNodeName(SPEED_NAME);
  NMP_ASSERT_MSG(speedCPNodeID != MR::INVALID_NODE_ID, "Control parameter does not exist (name=%s)!", SPEED_NAME);

  bankingCPNodeID = characterDefEuphoria->getNetworkDef()->getNodeIDFromNodeName(BANKING_NAME);
  NMP_ASSERT_MSG(bankingCPNodeID != MR::INVALID_NODE_ID, "Control parameter does not exist (name=%s)!", BANKING_NAME);

  getupMessageID = characterDefEuphoria->getNetworkDef()->getMessageIDFromMessageName(GETUP_NAME);
  NMP_ASSERT_MSG(getupMessageID != MR::INVALID_MESSAGE_ID, "Request does not exist (name=%s)!", GETUP_NAME);

  //--------------------------------------------------------------------------------------------------------------------
  // Run the network.
  const int32_t result = runNetwork(physXManager, characterManager);

  //----------------------------
  // When we are ready to exit we can terminate Game::CharacterManagerEuphoria to free any classes/memory it has stored.
  // Since Game::CharacterManagerEuphoria stores a pointer to the CharacterDef and Character instances it will manage
  // their termination as well.
  NMP_STDOUT("\nReleasing data");
  characterManager.term();
  Game::AnimSystemModuleEuphoria::term();
  NMP_STDOUT("Release complete");

  //----------------------------
  // Finally shut down PhysX.
  physXManager.destroyPhysicsObject(physXGroundObject);
  physXManager.destroyScene();
  physXManager.term();

  //--------------------------------------------------------------------------------------------------------------------
  // ...
  NMP_STDOUT("\nPress any key to exit ...");
  _getch();

  // ...
  return result;
}
//----------------------------------------------------------------------------------------------------------------------
